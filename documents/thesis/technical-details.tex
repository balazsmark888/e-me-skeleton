%!TEX root = dolgozat.tex
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Technical details}\label{ch:IMPLEMENTATION}

\section{Architecture}

E-me follows a commonly used N-tier architecture with three main parts: data, application (backend) and presentation (frontend) layers.
Each of these tiers can be broken down into layers that are defined by their responsibilities within the application.
This tier-based architectural approach adds modularity to the application which results in a low cost of change when compared to a single-tier structure.

\begin{figure}[h]
	\centering
	\includegraphics[scale=0.37]{general-architecture.png}
	\caption{General architecture}
\end{figure}

Along with the low cost of change, the independence of the layers allows for efficient future expansion of 
the application by means of multiple frontend platforms (ex. web applications, desktop applications), cloud storage/services and additional
Web API's that can easily be integrated into the existing application.
This, combined with the high compatibility of the .NET 5.0, provides a high level of scalability and maintainability for the application.

The application and presentation layers share a common class library that contains communication-related models and auxiliary methods.
This library allows both layers to benefit from the cross-platform nature of .NET 5.0, speeding up the process of development and
ensuring there are no discrepancies betweeen the layers in terms of encryption and communication.

\subsection{Application layer / Backend}

The architecture of the application layer has a similar design approach to the general architecture.
Consisting of 4 layers, the backend follows the single-responsibility principle in it's core.
Because of it's vertical structure, each layer is dependent on one single layer that is directly below it, providing a high level
of maintainability.

\begin{figure}[H]
	\centering
	\includegraphics[scale=0.40]{backend-architecture.png}
	\caption{Backend architecture}
\end{figure}

Due to this abstract layout, each layer can independently be replaced or updated. 
This aspect enables the utilization of external and/or third-party services and components without damaging the integrity of the application.

The API structure of the presentation layer allows for a wide variety of applications or even services in which the backend can be used: desktop applications,
WPF, web servers and more. This characteristic has major role in preserving the flexibility of the application layer.

Another component being responsible for the independece and reusability of the backend is the Data Access Layer. 
The role of this layer is to provide the data requested by the Business Layer. 
By reason of abstraction, this layer is independent of the technology of the data source. 
This enables the utilization of a wide range of data sources, including relational (SQL) and non-relational (NoSQL) databases, cloud services and/or APIs.

\subsubsection{Entity relations in the database layer}

\begin{figure}[H]
	\centering
	\includegraphics[scale=0.37]{entity-relationship-diagram.png}
	\caption{Entity-relationship diagram}
\end{figure}

\subsection{Presentation layer / Frontend}

The frontend of the application consists of three major layers that separate the user interface from the business logic and the data sources.
This separation allows for easy horizontal expansion and quick feature development.

The Presentation or UI Layer contains the visuals of the application which are separated into independent pages, however it is also responsible for receiving
user events and connecting them with the underlying services.
Each page contains it's own event listeners and separate View Model that is responsible for making use of the Business Layer,
which has a similar structure and role to the backend's Business Layer: data processing and calculations.

The main components of the Data Layer are Data Stores.
These stores are functionally similar to the repositories found in the Backend of the application, although here the data is retrieved using the endpoints
of the backend.

\begin{figure}[H]
	\centering
	\includegraphics[scale=0.32]{frontend-architecture.png}
	\caption{Frontend architecture}
\end{figure}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Technologies}

E-me makes great use of the cross-platform nature of .NET, meaning both the frontend and the backend of the application are implemented using the same
programming language: C\# 9.
The flexibility that is provided by the language and the wide variety of frameworks that make use of it allows for a cleaner codebase and a simpler
project structure when compared to a multilingual application design.

\subsection{Backend}

In terms of frameworks, the backend relies on .NET 5.0. Being the next major release of .NET Core following 3.1, this open-source cross-platform
software framework unifies a wide variety of frameworks .NET has to offer, including Windows Forms, ASP.NET Core, Azure and more.
This unification made the framework a perfect candidate for the backend of an application like E-me, since it can be used on a wide variety of
platforms and ensures long-term support.

E-me uses Internet Information Services (Microsoft IIS), which is an extensible web server software, as it's backend server.
It allows the application to communicate through HTTPS and provides it's separate development-time SSL certificate in order to secure the transport
layer. With the \emph{Development-time IIS support} feature, the web server allows \emph{hot reloading}, which speeds up the development and debugging
processes.

The main constituent of the backend itself is the ASP.NET Core web framework.
Using it's built-in IoC, this framework allows for a high level of abstraction in order to build well-structured enterprise level applications
using dependency injection \cite{seemann2012dependency} \cite{joshi2019asp}.
This framework is responsible for registering and configuring any other dependencies that may appear in the application backend.

Alongside with ASP.NET Core, one of the main components of the backend is the Entity Framework Core, which is the base of the 
\emph{Data Access Layer}.
In terms of building and maintaining the data access layer, E-me uses the code-first approach through \emph{EF Migrations}.
This approach provides flexibility in case of a potential database change and/or creation, but more importantly it allows 
the entire structure of the entities to be managed based on the models and datasets present in the code.

E-me relies heavily on encryption and security, which demands the utilization of advanced cryptographic libraries.
For this purpose, the application uses the \emph{Windows CNG (Cryptographic Next Generation) API}, which
enables exchanging documents and other data in a secure environment.
In terms of cryptography, this API provides a full implementation of the \emph{Elliptic-curve Diffie-Hellman} key agreement protocol,
alongside with many other cryptographic protocols and algorithms such as RSA, AES (Advanced Encryption Standard) or DSA (Digital Signature Algorithm)
and hash functions like SHA-2 or MD5.

The documents handled by the application are created and managed by the \emph{Telerik Document Processing Core} framework, which
provides flexibility and efficiency in terms of document management. 
It enables processing the most commonly used text, PDF and spreadsheet file formats, allowing the application
to create, import and export documents without relying on other external dependencies.

\subsection{Frontend}

Being a .NET-based application, E-me uses Microsoft's open-source mobile UI framework, \emph{Xamarin Forms} as a base for it's frontend.
This library allows developing native mobile applications on multiple platforms, such as iOS, Android or UWP using \emph{.NET Standard} \cite{hermes2015xamarin}. 
The multi-platform capability allows for a shared codebase and logic across all applications, which speed up the development process immensely.
Xamarin uses an XML-based interface designer in order to create the visuals for the application.
Alongside with the commonly used Xamarin UI components, E-me uses the \emph{Telerik UI for Xamarin, GoogleVision API and Syncfusion} UI
libraries for additional components and controls in it's user interface.



Although the frameworks used by the different layers of the application vary, these can have a shared codebase in the form
of a \emph{.NET Standard class library}, which can be used by both the backend and the frontend, allowing for closely integrated layers.

\section{Implementation}

Being cross-platform and having a wide range of possibilities in terms of future expansion and upgrades, E-me focuses heavily on scalability and maintainability.
In order to achieve these characteristics, multiple factors have to be considered during development, such as project structure, dependencies and code reusability.
For this purpose, both the backend and the frontend of the application relies on \emph{Dependency Injection}.
This technique allows for a service-based structure within the application and it is an elegant way of implementing loosely coupled classes.

\subsection{Backend}

The backend of E-me is separated into 5 projects that are defined by their role within the application.
These projects are targeting the \emph{.NET 5.0} framework, one exception being the \emph{Shared} project, which is used as the common
codebase for the backend and the frontend.
The majority of the projects are \emph{Class Libraries}, which are collections of pre-coded object-oriented templates and classes. 
These libraries revolve around the main entry-point of the application, the \emph{MVC project}.

\subsubsection{The MVC project}

As the main entry-point of the application backend, this project is responsible for configuring and registering all dependencies and services
E-me requires and utilizes.
This configuration of the \emph{IoC (inversion of control)} and the registration of dependencies take place in the \emph{Startup} class.
This class is registered to the \emph{Host Builder} as soon as the application starts.

\begin{lstlisting}
  public static IHostBuilder CreateHostBuilder(string[] args)
  {
	return Host.CreateDefaultBuilder(args)
		.ConfigureWebHostDefaults(webBuilder =>
		{
			webBuilder.UseStartup<Startup>();
		});
  }
\end{lstlisting}

Representing the presentation layer, this project defines the \emph{API Controllers} which are representing the endpoints of the backend.
These controllers are the connection points through which the backend is able to communicate with other layers of the application.
The endpoints of these controllers follow the same route structure: \emph{[base-address]/api/[controller-name]/[action-name]},
for example: \emph{https://e-me.Mvc/api/auth/login}.
All endpoints of the application require \emph{HTTPS} to be accessed and send response in \emph{JSON} format to ensure that the receiving
party is able to interpret the message.

One of the most important of these controllers is the \emph{AuthController}, which is responsible for 
registering, authenticating and de-authenticating the users of the application.
This is the only controller that can be accessed by an unauthenticated user, since the rest of them handle more 
sensitive data.


\begin{figure}[H]
	\centering
	\includegraphics[scale=0.65]{auth-endpoints.png}
	\caption{AuthController endpoints}
\end{figure}

Once a user is authenticated, they are able to access the protected endpoints.
A controller's or and endpoint's protected nature is marked by the \emph{Authorize} declarative attribute.
When accessed, the endpoints marked with this attribute automatically verify the authorization header of the request and the role of the current user if necessary.

\begin{lstlisting}
  [Authorize]
  [ApiController]
  public class UserDetailsController : Controller
\end{lstlisting}

Two of the main protected controllers are the \emph{UserDocumentsController} and the \emph{DocumentTemplatesController}.
These two combined are responsible for handling any document-related user requests, such as reading or deleting by id, getting available or owned documents etc. 
All of these actions contain an extra layer of validation in order to ensure that the current user is eligible for viewing, modifying or removing 
the specified documents or types. 

\begin{figure}[H]
	\centering
	\includegraphics[scale=0.65]{user-document-endpoints.png}
	\caption{UserDocumentsController endpoints}
\end{figure}

\begin{figure}[H]
	\centering
	\includegraphics[scale=0.65]{document-template-endpoints.png}
	\caption{DocumentTemplatesController endpoints}
\end{figure}

Apart from these three major controllers, there are three that are significantly more compact and have much fewer endpoints:
\emph{DocumentTypesController, OneTimeAccessTokensController} and \emph{UserDetailsController}.
These three cover the non-document-related actions within the application, which include modifications of the personal information of the user, 
requesting a \emph{document-sharing token} (represented as a QR code in the frontend) or listing the document types that can be managed through the application.

\begin{figure}[H]
	\centering
	\includegraphics[scale=0.65]{endpoints.png}
	\caption{Endpoints of the minor controllers}
\end{figure}

\subsubsection{The Business project}

As the name suggests, this intermediate project represents the Business Layer of the application backend.
The project itself consists of service contracts (interfaces), factories and implementations that make use of the data-access objects from the 
data layer.
These services perform calculations, alterations and complex operations on the data provided by the underlying layer and are utilized by the 
above mentioned MVC project as the source of processed data.
They are registered in the \emph{Startup} class and injected in the constructors of the controllers by the \emph{IoC container} upon 
accessing the endpoints of the corresponding controller:

\begin{lstlisting}
  public AuthController(IAuthService authService, IUserService userService)
  {
	_authService = authService;
	_userService = userService;
  }
\end{lstlisting}

This loose class coupling allows for multiple implementations of the services.
These implementations follow the same structure (contract), but don't necessarily have matching outputs and/or dependencies.
The implementation is selected either using the \emph{factory pattern} or in the moment of registering the service to the \emph{IoC container}.
Example for a service contract:

\begin{lstlisting}
  public interface ITokenGeneratorService
  {
	string Generate(string userName, DateTime validTo, string role);
	string GeneratePasswordResetToken(string username, DateTime validTo);
	string GenerateOneTimeAccessToken(Guid userDocumentId, DateTime validTo);
  }
\end{lstlisting}

\subsubsection{The Model project}

One other major building block of the backend is the \emph{Model} project.
As the \emph{MVC} represented the presentation layer of the application backend, the \emph{Model} implements the data-access layer.
Having said that, this project is responsible for data persistence-related operations via \emph{Entity Framework Core}.
In order to manage the data on the server, the project has to model the structure of the database in the form of classes (\emph{Models}) and \emph{DbSets} which represent
tables and the underlying data respectively.

The framework allows for multiple directions in managing the database structure (ex. database-first or code-first), out of which E-me 
uses the code-first option.
This kind of implementation denotes that the database is automatically generated by the framework using the pre-coded models and defined constraints.
For representing various versions of the data structure that may appear during development, database migrations are used which contain the alterations
that occured after the previous version of the database was generated.
These migrations can be reverted and/or modified, providing flexibility when designing the data-layer and also ensuring that the structure of the database 
is correctly representing the model-structure from the code at all times.

The outermost layer of the Model project consists of \emph{repositories}.
These classes represent the data-access objects (\emph{DAO}), which are used by the services in the Business Layer to retrieve raw or pre-processed data.
Each data model has its own repository that allows for performing the basic operations on the corresponding table from the database.
These operations include deletion, insertion and querying.
Each repository is inherited from the \emph{BaseRepository} abstract class, which implements the above mentioned basic operations:

\begin{lstlisting}
  public abstract class BaseRepository<TEntity> : BaseRepository, IBaseRepository<TEntity> where TEntity : Models.BaseModel
\end{lstlisting}

The more complex operations and non-generic queries are implemented individually in each repository depending on the needs of the corresponding service
that uses the DAO.
This can be seen in the following example:

\begin{lstlisting}
  public class OneTimeAccessTokenRepository : BaseRepository<OneTimeAccessToken>, IOneTimeAccessTokenRepository
  {
	...
    public async Task<OneTimeAccessToken> FindByUserDocumentIdAsync(Guid userDocumentId)
	{
		return await All.FirstOrDefaultAsync(p => p.UserDocumentId == userDocumentId);
	}
  }
  public interface IOneTimeAccessTokenRepository : IBaseRepository<OneTimeAccessToken>
  {
	Task<OneTimeAccessToken> FindByUserDocumentIdAsync(Guid userDocumentId);
  }
\end{lstlisting}

\subsection{Frontend}

In terms of volume, the frontend of the application is substantially smaller than the backend.
It consists of 3 projects, one of them being automatically generated as a result of using \emph{Xamarin Forms}.
The main entrypoint here is the \emph{Mobile} projects which contains the majority of the frontend implementation and can be separated into 
4 major building blocks: services, models, views and view models (MVVM).

\subsubsection{The Mobile project}

Being a \emph{Xamarin Forms} project, the Mobile part of the frontend is a \emph{.NET Standard 2.1} class library which contains the shared codebase across
all the mobile platforms that are part of the application.
This project serves as a template for Xamarin to generate the native code for each individual platform (Android, iOS or UWP).
In case of E-me, the Android platform is targeted which denotes that the generated libraries and binaries are using \emph{Mono runtime}
in order to access all of the native Android APIs.

The setup of the project is similar to the \emph{MVC} project from the backend of E-me, since it uses the same concepts when it comes to
inversion of control and dependency injection.
Similarly, a \emph{Startup} class is used to register services, visual components (views) and view models to the \emph{IoC container} for loose coupling.

The main component of the presentation layer is the \emph{AppShell}.
This shell is a tab-based wrapper for the views of the frontend.
The shell's visibility alters depending on the currently rendered view; some views are not required to be seen among the tabs of the application shell (ex. Login view, Registration view).

The visual components/views of the frontend are refferred to as \emph{pages}.
Each page consists of two parts: an XML file representing the visuals of the page and a C\# class that provides the functionality for these visuals.
The various view models and services are injected into the constructors of these underlying classes:

\begin{lstlisting}
  public RegisterPage(RegisterViewModel registerViewModel, IUserService userService, IMapper mapper, INavigationService navigationService)
  {
	_userService = userService;
	_mapper = mapper;
	_registerViewModel = registerViewModel;
	_navigationService = navigationService;
	InitializeComponent();
	BindingContext = registerViewModel;
  }
\end{lstlisting}

The services of the frontend include \emph{cryptographic, communicaiton and storage services}.
The cryptographic service makes use of the shared key-derivation and encryption methods implemented in the \emph{Shared} project.
It is used in the decryption of documents received from the application backend and upon generating keys for the \emph{Diffie-Hellman key exchange}(see \hyperref[end-to-end-encryption]{End-to-end encryption}). 

Communication services are responsible for establishing connection with the backend of the application.
This connection is made possible by \emph{HttpClients} which are retrieved from a \emph{HttpClientFactory}.
The role of this factory is to create clients that already include the authorization header (if the user is authenticated) and base address of the backend server.
These services create request messages based on the needs of the user and handle the interpretation of the response from the server (deserialisation).

E-me makes use of the \emph{Android Keystore system} in order to securely store sensitive information (keys, tokens etc.) via the storage services.
These services are responsable for reliable data retrieval either from the keystore or from configuration files depending on the needs of the user.

\subsection{Use cases}

The use cases in E-me can be categorised by their actors, since they don't have overlapping instances.

\subsubsection{Unauthenticated user}

As for a unauthenticated user, there are two possible actions that can be perfomed: Login and Registration.
The detailed description of the login process can be found in the \hyperref[end-to-end-encryption]{Security section}.

The process of registration starts at the \emph{Registration page} on the frontend.
Upon submitting the registration form, a \emph{UserRegistrationDto} object is created containing all the necessary information for creating a new user.
After a successful backend validation via the \emph{UserService}, a new record in the User table is created, followed by new records in the \emph{UserSecurityRole} and 
\emph{UserDetail} tables.
If the creation of the new records was successful, the backend server sends an adequate response (200 OK) in order to signal the client about the successful registration.

\begin{figure}[H]
	\centering
	\includegraphics[scale=0.52]{use-case-diagram-unauth}
	\caption{Use-case diagram (unauthenticated user)}
\end{figure}

\subsubsection{Authenticated user}

Following a successful login, a user is able to perform their document-related actions, which include viewing, sharing, deleting and/or requesting documents, 
and also have access to their personal information.

One of the main features of E-me is the automatic document creation using the personal details of the user.
The process of requesting a document starts at selecting a document type (template) from the list of available documents.
Using the \emph{DocumentService}, the frontend proceeds to send the id (GUID) of the template to the \emph{RequestFromTemplate} endpoint of the server.
Upon receiving a valid template ID, the server loads the reuqested template document from the database.
Using the \emph{Telerik Document Processing} library, the \emph{DocumentProcessorService} identifies the form fields of the corresponding document
and looks for matching fields in the personal details of the user.
Upon mapping the fields, the service proceeds to fill the ones that have matching information about the user.\pagebreak

\begin{lstlisting}
  public UserDocument GetDocumentFromTemplate(DocumentTemplate documentTemplate, UserDetail userDetail)
  {
	var userData = userDetail.MapToDictionary();
	var radDocumentTemplate = DocumentProcessing.GetFixedDocumentFromBytes(documentTemplate.File);
	DocumentProcessing.FillDocumentFormFieldsByFieldNames(radDocumentTemplate, userData);
	var filledDocument = DocumentProcessing.GetBytesFromFixedDocument(radDocumentTemplate);
	return filledDocument;
  }
\end{lstlisting}

Upon successfully filling the forms of the document, the newly created instance is saved in the database.
After successfully creating the necessary instances in the database, the server retrieves the encryption key information about the user from the database
to encrypt and hash the newly created document.
If the encryption was successful, a \emph{UserDocumentDto} is created which contains the encrypted file in \emph{base64} format and the hash of the file to
ensure data integrity and authenticity.

\begin{figure}[H]
	\centering
	\includegraphics[scale=0.52]{use-case-diagram}
	\caption{Use-case diagram (authenticated user)}
\end{figure}

After receiving the DTO from the server, the frontend client validates the hash of the document and decrypts it using the shared encryption key stored in the \emph{Android Keystore}.
If the decryption was successful, the client presents the PDF document to the user via the \emph{Syncfusion PDF Viewer}. 

When sharing a document, the document ID is sent to the server by the \emph{DocumentService} from the frontend.
Upon receiving a correct document ID and performing validations on the user's eligibility, the backend generates a token containing information about the
document which is available for \emph{one hour} after being generated.
After this token is received on the client side, it is represented as a QR code.

When reading the QR code using the built-in scanner, the mobile client retrieves the above mentioned token and sends it to the backend.
In case of a valid token, the server perform an encryption and hashing of the corresponding document identical to the one performed when creating a
new one.
After the client receives the encrypted document, it performs the same actions as mentioned above to present the document.

\section{Security}

As a document-handling application, E-me relies heavily on secure communication, data storage and encryption.
In order to achieve the required level of protection, the application uses a handful of libraries that target various layers within the backend and the frontend.

\subsection{Data-layer security}

First and foremost, E-me utilizes \emph{Entity Framework Core Data Encryption}, which is a plugin for the above mentioned \emph{Entity Framework Core},
 to add support of encrypted fields using built-in or custom encryption providers.
This library ensures the protected storage of the data via encryption.
This way the data stored in the database cannot be interpreted by other parties, not even in a case of a security breach or database failure.
In the case of E-me, a built-in encryption provider is used which enables \emph{AES-256} encryption configured with a CBC (cipher-block chaining) cipher.
The algorithm uses a secret key stored in the configuration of the application.

\begin{lstlisting}
  private AesProvider CreateAesProvider()
  {
	var key = Encoding.ASCII.GetBytes(_authSettings.SecretKey);
	var provider = new AesProvider(key, CipherMode.CBC,	 PaddingMode.Zeros);
	return provider;
  }
\end{lstlisting}

The data encryption library allows for independent protection of model attributes, providing flexibility for the developers in selecting sensitive fields
that require encryption. This selection can greatly reduce the time consumption of the encryption and is preformed via the \emph{Encrypted} field attribute:

\begin{lstlisting}
  [Encrypted]
  public string FullName { get; set; }
\end{lstlisting}

\subsection{End-to-end encryption (E2EE)}\label{end-to-end-encryption}

The second layer of security is located in the \emph{Business Layer} of the application backend.
One of the main features of E-me is the end-to-end encrypted (E2EE) document transfer which is achieved by this second layer.
In order to successfully perform an encryption on the backend followed by a decryption on the frontend, the two sides must complete a secure key exchange beforehand.
This exchange occurs upon a user's successful login to the system.

Upon receiving the user's credentials, a key pair (private and public keys) is generated on the frontend of the application.
The key generation and derivation takes place in the \emph{EcdhKeyStore} class which uses a password-based key derivation functon (\emph{PBKDF2}) with a \emph{SHA512} hash function
as the private key generator and \emph{X25519 Elliptic Curve Diffie-Hellman} to derive a public key from the generated private key \cite{bernstein2006curve25519}.

\begin{lstlisting}
  public EcdhKeyStore()
  {
	using var rngCsp = new RNGCryptoServiceProvider();
	var salt = new byte[SaltSize];
	var rawKey = new byte[RawKeySize];
	rngCsp.GetBytes(salt);
	rngCsp.GetBytes(rawKey);
	PrivateKey = new Rfc2898DeriveBytes(rawKey, salt, Iterations, HashAlgorithmName.SHA512).GetBytes(KeySize);
	PublicKey = Curve25519.GetPublicKey(PrivateKey);  
  }
\end{lstlisting}

The public part of the key pair is included in the login request in order to be processed on the backend server.
Upon a successful verification of the login credentials, the backend's authentication service generates it's own private and public key pairs.
These --- combined with the client's public key --- enable the derivation of a third key (shared secret) and a shared \emph{AES Initialization Vector (IV)} which can be used for encryption and hashing in the future \cite{abdullah2017advanced}.
This key derivation process is followed by the storage of the keys and hash parameters in an encrypted form in the database \cite{gorman2020encryption}.

\begin{lstlisting}
  public void SetPeerPublicKey(byte[] peerPublicKey)
  {
	PeerPublicKey = peerPublicKey;
	SharedKey = Curve25519.GetSharedSecret(PrivateKey, peerPublicKey);
	HmacKey = SharedKey;
	DerivedHmacKey = Curve25519.GetSharedSecret(HmacKey, HmacKey);
	using var aesProvider = new AesCryptoServiceProvider
	{
		Key = SharedKey
	};
	aesProvider.GenerateIV();
	IV = aesProvider.IV;
  }
\end{lstlisting}

The server's public key alongside with the \emph{IV} is then included in the response of the login request.
This way the client is able to generate an identical shared secret using the same methodology.
In the end of the authentication process both sides will possess a secret encryption key and hash parameters despite not sharing them directly.
These secret values are used whenever a document is shared between the two parties.
In addition to the encryption of these documents, the application makes use of the hash-based message authentication (\emph{HMAC}) in order to 
ensure data integrity and authenticity.

\subsubsection{Transport Layer Security (TLS)}

The third and most general layer of security can be found on the transport layer in the form of \emph{HTTPS}.
This layer is responsible for providing communications security over the network using a self-signed \emph{SSL Certificate}.
It enables communication bewteen parties in an encrypted form and it is used in all of the application's requests.

\subsubsection{Authentication and authorization}

The majority of E-me's endpoints require authorization to be accessed.
In order to authenticate and authorize a user, the application utilizes \emph{JSON Web Tokens (JWT)} \cite{ethelbert2017json}.
These tokens are generated by the authentication service upon providing the correct login credentials from the application frontend and are to be
included in the header of the HTTP requests by the client.
These tokens contain information about the user, the generator of the token and timestamps which are used to verify a token's validity.
On the server-side, the \emph{JwtTokenValidatorMiddleware} is responsible for processing the request header and validating the incoming tokens for each request.